---
title: "Assignment 4"
author: "Devin Koehl"
date: "6/17/2019"
output: 
    html_document:
      theme: united
      toc: true
      toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)

```

# Synopsis

Albuminuria, an established marker of kidney disease, affects more than 10 million US adults. It is a strong independent risk factor for cardiovascular disease (CVD), end-stage renal disease, and all-cause mortality. Despite its high prevalence and prognostic importance, most individuals with albuminuria are unaware of having this condition. This low awareness is present in the general population and in high-risk groups, including individuals with diabetes. Research has shown that population-wide screening for albuminuria is not cost-effective; however, screening for albuminuria may be beneficial among high-risk individuals. (More info [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4671433/) and [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3144301/))


# Instructions

Complete the following problems using the synthetic cardiovascular disease dataset (`data/synthdata_cvd.csv`). Use the `start_here.html` file to check your answers.

Here are a few resources with info that can help you engage with these problems: 

1. Hadley Wickham talks [functions](https://www.youtube.com/watch?v=M4fMccWy5lU)

2. Hadley Wickham talks [iteration](https://www.youtube.com/watch?v=GyNqlOjhPCQ)

**Note** these links will only work if you open the html document in your web browser (they will not work if you try to open them from the Rstudio viewer pane).


```{r, echo = TRUE}

library(tidyverse)   # for keeping data tidy
library(knitr)       # for kable
library(kableExtra)  # for nice tables
library(ggforce)     # use the force!

in_data <- read_csv('data/synthdata_cvd.csv')

theme_set(
  new = theme_bw() + 
  theme(
    panel.grid = element_blank(),
    text = element_text(face = 'bold', size = 14)
  )
)


```

# Problem 1

Do the following using `in_data`.

- Select `age`, `weight`, `height`, `neck`, `sbp`, `dbp`, `hba1c`, `trigs`, `albumin`, `creatinine`, `hdl`, and `ldl` as columns to keep for this analysis. 

- Remove all rows with missing values for the columns listed above.

- Create an indicator variable for albuminuria: `albumin / creatinine > 30` versus `albumin / creatinine <= 30`. (prevalence of albuminuria is printed below). 

- Remove the `albumin` and `creatinine` columns from the data after making the `albuminuria` column.

- Call the resulting dataset `cvd`. The `cvd` data **will be used throughout the assignment**

- Make sure the dimensions of your data match mine

```{r}

#Select all variables
cvd <- in_data %>%
  select(age,
         weight,
         height,
         neck,
         sbp,
         dbp,
         hba1c,
         trigs,
         albumin,
         creatinine,
         hdl,
         ldl) %>%
  #Drop NA
  drop_na() %>%
  #Create albuminuria
  mutate(albuminuria = if_else(albumin / creatinine > 30, 1, 0)) %>%
  #Remove albumin and creatinine
  select(-albumin,-creatinine)

#Check dimensions
dim(cvd)


```


# Problem 2

- Create an indicator variable for having systolic blood pressure greater than or equal to 140 mm Hg versus less than 140 mm Hg. **Use values of 0 and 1 to indicate systolic blood pressure < 140 and greater than or equal to 140 mm Hg, respectively.** Name the variable `sbp_binary`. This could be done in dplyr's mutate function, but I recommend using base R for two reasons:

1. It never hurts to know base R
2. It is usually more straightforward to write functions in base R
3. The next problem will ask you to write a function for this task

**Reminder: in base R, the `$` sign is used to access columns in a dataset**

```{r}

problem_2 <- cvd %>%
  
  #Create binary variable
  mutate(sbp_binary = if_else(sbp >= 140, 1, 0))

#Calculate specificity from equation given
specificity <-sum(problem_2$sbp_binary == 0 & problem_2$albuminuria == 0) / sum(problem_2$albuminuria == 0)

#Calculate sensnity from equation given
sensitivity <- sum(problem_2$sbp_binary == 1 & problem_2$albuminuria == 1) / sum(problem_2$albuminuria == 1)

#Calculate Youden from equation given
Youden <- sensitivity + specificity - 1


#Check
Youden

```

- Suppose we wanted to use `sbp_binary` to determine who we should screen for albuminuria. In other words, if a person has systolic blood pressure greater than or equal to 140 mm Hg, we screen them for albuminuria. Otherwise, we don't screen for albuminuria.

- Compute the sensitivity, specificity, and Youden index for indentifying cases of albuminuria using this approach.

- Note that $$\text{sensitivity} = \frac{\text{# of true positive cases correctly classified}}{\text{# of true positive cases}},$$ $$\text{specificity} = \frac{\text{# of true negative cases correctly classified}}{\text{# of true negative cases}},$$ $$\text{Youden's index} = \text{sensitivity} + \text{specificity} - 1$$. 

**Some notes for clarification:** 

1. We are working with a rudimentary classifier. A classifier is a decision rule that we can apply to predict which category a person fits into (i.e., albuminuria or no albuminuria) based on their input information (i.e., systolic blood pressure). 

2. The main reason we want to determine the overall performance of a classifier is that it costs money to screen for albuminuria, and if we do not identify albuminuria it can lead to CVD or other life-threatening events. 

3. Therefore, we want to make sure that a large proportion of people who actually have albuminuria are screened (i.e., we have a classifier with high sensitivity). 

4. We *also* want to make sure a large proportion of people who don't have it are not screened (i.e., we have a classifier with high specificity). 

5. Youden's index is a standard way to measure the overall performance of a classifier since it combines sensitivity with specificity. A perfect classifier gets a Youden index of 1. Any classifier that gets a Youden index of < 0 is not very good. 

6. Here is the value of Youden's index that I get for our systolic blood pressure classifier.



**But wait, how do we know if 140 mm Hg is the *best* cut-point to use for systolic blood pressure?**

# Problem 3

- Write a function called `split_sbp` that takes the following inputs: `data` and `cut_val`. The body of the function should create a variable called `sbp_binary` in the `data` that takes a value of 1 if `sbp` is greater than or equal to `cut_val` and 0 otherwise. Notably, the function should return the augmented `data` which has one additional column: `sbp_binary`.


- Write a function called `cmp_youden` that has three inputs:

    + `data`, a dataset containing the `classifier` and `outcome variable`

    + `classifier`, a column in `data` that has 0/1 values indicating the predicted status. 

    + `outcome`, a colum in `data` that has 0/1 values indicating the actual status.
    
- `cmp_youden` should return the value of Youden's index that results from classifying participants for `outcome` based on  `classifier`, both of which should be column names in `data`. 

- Use this function to compute Youden's index for classifying albuminuria based on splitting variables that are defined by having

    1. systolic blood pressure greater than or equal to 120 versus less than 120 mm Hg

    2. systolic blood pressure greater than or equal to 130 versus less than 130 mm Hg

    3. systolic blood pressure greater than or equal to 140 versus less than 140 mm Hg

    4. systolic blood pressure greater than or equal to 150 versus less than 150 mm Hg


```{r}


#Make function
split_sbp <- function(data, cul_val) {
  data_out <- data %>%
    mutate(sbp_binary = if_else(sbp >= cul_val, 1, 0))
  return(data_out)
}


#Make function - basically just replicating th previous problem
cmp_youden <- function(data, classifier, outcome) {
  data_out2 <- data %>%
    mutate(
      classifier = if_else(sbp_binary == 1, 1, 0),
      outcome = if_else(albuminuria == 1, 1, 0)
    )
  
  #Calculate sens
  sensitivity <-
    sum(data_out2$classifier == 1 &
          data_out2$outcome == 1) / sum(data_out2$outcome == 1)
  specificity <-
    sum(data_out2$classifier == 0 &
          data_out2$outcome == 0) / sum(data_out2$outcome == 0)
  Youden <- sensitivity + specificity - 1
  return(Youden)
}


#Make table

#The values we want
x <- c(110, 120, 130, 140, 150)

#The map function
map_dbl(x, ~split_sbp(cvd, cul_val=.) %>%
    
  #Compute Youden
  cmp_youden(1,1)) %>% 
  round(digits=4) %>%
  enframe() %>%
  
  #Create the table
  mutate(name= c(110,120,130,140,150))%>%
  kable(col.names = c("Cut-point ","Youdenâ€™s Index")) %>%
  kable_styling(bootstrap_options = c("striped","hover"),
                full_width = FALSE)


```

*Based off this comparison, which cut-point seems optimal? Is it possible that we are still missing the optimal cut-point?*

# Problem 4

- Create a vector called `sbp_cut_points` containing 50 equally spaced values ranging from the 15th to the 85th percentile of `sbp`. **Hint:** Use the `seq()` function. 

```{r}

#Create the sbp_cut points
sbp_cut_points <-
  seq (as.numeric(quantile(cvd$sbp, probs = 0.15)), as.numeric(quantile(cvd$sbp, probs = 0.85)), length.out = 50)


#map double
problem_4 <- map_dbl(sbp_cut_points, ~ split_sbp(cvd, cul_val = .) %>%
                       cmp_youden(1, 1)) %>%
  enframe() %>%
  mutate(name = sbp_cut_points)


#plot the values
problem_4 %>%
  
  #Ggplot what we want on x and y
  ggplot(aes(x = name, y = value)) +
  
  #We want geom_point
  geom_point(shape = 21,
             fill = "red",
             color = "black") +
  
  #Add geom lines
  geom_line(linetype = "dashed", color = "grey") +
  labs(x = "systolic blood pressure cut-point for classification, mm Hg",
       y = "Youden's index") +
  
  #Add the circle and filter to the value we want, very similar to lecture
  geom_mark_circle(
    aes(
      filter = value == max(value),
      label = "Best cut-point :124 mm hg",
      description = "This is the systolic blood pressure cut-point that maximizes Youden's index for classification of albuminuria"
    ),
    color = "green",
    expand = 0.02,
    label.buffer = unit(20, "mm"),
    label.fontsize = c(12, 10)
  )



```


# Problem 5

Modify the `split_sbp()` function from Problem 3 so that it has three inputs: 

1. `data` the dataset where the variable is

2. `cut_val` the value that will be used to cut the continuous variable into an indicator

3. `var_name` the name of the variable that will be cut into an indicator.

name the function something short and descriptive (I used `split_var()`)

```{r}

#Adding an extra parameter

### very close to having a perfect function here. 
### mutate is going to look for a variable in data 
### called var_name (but there isn't any).
### check out this tutorial for functions in the tidyverse:
### https://speakerdeck.com/lionelhenry/programming-in-the-tidyverse


split_var <- function(data, cut_val, var_name) {
  data3 <- data %>%
    mutate(sbp_binary = if_else(var_name >= cut_val, 1, 0))
  data3
}

```

# Problem 6

compare systolic blood pressure to age in years. Which combination of variable and cut-point provide the best classifier for albuminuria? Make a graphic to justify your answer. 

```{r}

#Similar to sbp cut points
age_cut_points <- seq ( as.numeric(quantile(cvd$age, probs = 0.15)), as.numeric( quantile(cvd$age, probs = 0.85)), length.out =50)
tab1 <- data.frame (
  val = c( rep("sbp",len= 50), rep( "age", len= 50)),
  cut_points = c( sbp_cut_points, age_cut_points),
  index = c( map_dbl( sbp_cut_points, ~split_sbp(cvd, cul_val=.) %>% cmp_youden(1,1) ),
            map_dbl( age_cut_points, ~split_var(cvd, . , cvd$age) %>% cmp_youden(1,1) )))
tab1 %>%
  ggplot(aes(x= cut_points, y= index)) +
  geom_point(shape= 21, color= "black", fill= "red") +
  geom_line(linetype= "dashed", color= "grey") +
  labs(x= "cut-point for classification",
        y= "Youden's index") +
  facet_wrap(.~ val, scales= "free_x",
             labeller =  labeller( 
               val= c( age="Age in years", sbp= "Systolic blood pressure in mm Hg"))) +
  map(.x= c("age", "sbp"), ~ geom_mark_circle(data= filter(tab1,val== .x ),aes(filter= index == max(index), 
                       label= paste0("Best cut-point :", round(cut_points[ which.max(index)]) ),
                       description= "This is the cut-point that maximizes Youden's index"),
                   color="green",
                   expand= 0.02,
                   label.buffer=unit(30,"mm"),
                   label.fontsize = c(12, 10)))




```

